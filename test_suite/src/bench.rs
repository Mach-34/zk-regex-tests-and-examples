use std::{fmt::Display, path::Path, process::Command};

use anyhow::Context;
use serde::{Deserialize, Serialize};
use serde_json::Value;

use crate::constants;

/// Error that may happen in the command execution.
#[derive(thiserror::Error, Debug)]
pub enum Error {
    #[error("error executing the gate-count command: {0:?}")]
    CommandOutputError(String),
}

/// Results of the benchmark.
///
/// This results are extracted using the command `bb gates -b <target>`
#[derive(Deserialize, Serialize)]
pub struct BenchResult {
    /// Number of ACIR opcodes generated by the compiler.
    pub acir_opcodes: u32,
    /// The number of gates.
    pub circuit_size: u32,
    /// Number of gates per opcode.
    #[serde(skip_serializing)]
    pub gates_per_opcode: Vec<u32>,
    /// Regex
    #[serde(skip_deserializing)]
    pub regex: String,
    /// Tells if this benchmark was performed using the gen_substr() function.
    #[serde(skip_deserializing)]
    pub with_gen_substr: bool,
}

impl Display for BenchResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "ACIR opcodes: {}\nCircuit size: {}\nGates per opcode: {:?}",
            self.acir_opcodes, self.circuit_size, self.gates_per_opcode
        )
    }
}

/// Container for the benchmark results for each test.
#[derive(Serialize, Default)]
pub struct BenchReport(Vec<BenchResult>);

impl BenchReport {
    /// Adds a result to the report.
    pub fn push_result(&mut self, result: BenchResult) {
        self.0.push(result);
    }

    /// Save the report to a CSV file given by the path.
    pub fn save(self, path: &Path) -> anyhow::Result<()> {
        let mut writer = csv::Writer::from_path(path)?;
        for result in self.0 {
            writer.serialize(result)?;
        }
        Ok(())
    }

    /// Returns if the report has any benchmark result or not.
    pub fn is_empty(&self) -> bool {
        self.0.is_empty()
    }
}

/// Executes the command to count the gate. This command must be executed after
/// the code is successfully compiled. To count the number of gates, we use the
/// command `bb gates -b <target>`.
pub fn execute_count_gate_command() -> anyhow::Result<BenchResult> {
    let output = Command::new("bb")
        .args(["gates", "-b"])
        .arg(constants::DEFAULT_TARJET_JSON_FILE)
        .output()
        .context("the gate-count command was not executed correctly")?;
    if !output.status.success() {
        anyhow::bail!(Error::CommandOutputError(String::from_utf8(output.stderr)?));
    }

    let str_result_json = String::from_utf8(output.stdout)?;
    let output_value: Value = serde_json::from_str(&str_result_json)?;

    let bench_result: BenchResult =
        serde_json::from_str(&output_value["functions"][0].to_string())?;
    Ok(bench_result)
}
