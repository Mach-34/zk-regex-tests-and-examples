use std::{fmt::Display, process::Command};

use anyhow::Context;
use serde::Deserialize;
use serde_json::Value;

use crate::constants;

/// Error that may happen in the command execution.
#[derive(thiserror::Error, Debug)]
pub enum Error {
    #[error("error executing the gate-count command: {0:?}")]
    CommandOutputError(String),
}

/// Results of the benchmark.
///
/// This results are extracted using the command `bb gates -b <target>`
#[derive(Deserialize)]
pub struct BenchResult {
    /// Number of ACIR opcodes generated by the compiler.
    pub acir_opcodes: u32,
    /// The number of gates.
    pub circuit_size: u32,
    /// Number of gates per opcode.
    pub gates_per_opcode: Vec<u32>,
}

impl Display for BenchResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "ACIR opcodes: {}\nCircuit size: {}\nGates per opcode: {:?}",
            self.acir_opcodes, self.circuit_size, self.gates_per_opcode
        )
    }
}

/// Executes the command to count the gate. This command must be executed after
/// the code is successfully compiled. To count the number of gates, we use the
/// command `bb gates -b <target>`.
pub fn execute_count_gate_command() -> anyhow::Result<BenchResult> {
    let output = Command::new("bb")
        .args(["gates", "-b"])
        .arg(constants::DEFAULT_TARJET_JSON_FILE)
        .output()
        .context("the gate-count command was not executed correctly")?;
    if !output.status.success() {
        anyhow::bail!(Error::CommandOutputError(String::from_utf8(output.stderr)?));
    }

    let str_result_json = String::from_utf8(output.stdout)?;
    let output_value: Value = serde_json::from_str(&str_result_json)?;

    let bench_result: BenchResult =
        serde_json::from_str(&output_value["functions"][0].to_string())?;
    Ok(bench_result)
}
